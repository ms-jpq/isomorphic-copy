#!/usr/bin/env python3

from argparse import ArgumentParser, Namespace
from os import environ, getcwd, unlink
from os.path import basename, join, realpath, relpath
from shutil import which
from socket import socket, AF_UNIX, SOCK_STREAM
from socketserver import BaseRequestHandler, UnixStreamServer
from subprocess import run, Popen, PIPE
from sys import argv, stderr, stdin, stdout
from time import sleep
from typing import List, Tuple, Union


def tmux_cp(data: str) -> None:
  pass
  # if environ.get("TMUX", None):
  #   run(["tmux", "set-buffer", data])


def clippy(data: str) -> None:

  if which("pbcopy"):
    run(["pbcopy"], input=data.encode())
  else:
    print("⚠️ No clipboard integration ⚠️", file=stderr)


def clean_socket(path: str) -> None:
  try:
    unlink(path)
  except IOError:
    pass


def locate_prog() -> str:
  home = environ["HOME"]
  canonical = realpath(__file__)

  if canonical.startswith(home):
    p = join(getcwd(), canonical)
    prog = relpath(p, home)
    return f"$HOME/{prog}"
  else:
    return canonical


def supervise(args: List[str]) -> None:
  prog = locate_prog()
  process = Popen(
      ["ssh", *args, f"{prog} --daemon"],
      stdout=PIPE,
      stderr=PIPE)

  buf = bytearray()
  while True:
    code = process.poll()
    if code:
      print(f"ssh exited - {code}", file=stderr)
      print(process.stderr.read().decode(), file=stderr)
      print("\a")
      return

    line: bytes = process.stdout.readline()
    for b in line:
      if b == 0:
        data: str = buf.decode()
        buf = bytearray()
        tmux_cp(data)
        clippy(data)
        break
      else:
        buf.append(b)


def remote_daemon(path: str) -> None:
  class Handler(BaseRequestHandler):
    def handle(self) -> None:
      with self.request.makefile() as fd:
        data: str = fd.read()
        stdout.write(data)
        stdout.flush()

  clean_socket(path)
  with UnixStreamServer(path, Handler) as srv:
    srv.serve_forever()


def remote_copy(path: str, data: str) -> None:
  with socket(AF_UNIX, SOCK_STREAM) as sock:
    sock.connect(path)
    sock.sendall(data.encode())
    sock.sendall(b'\0\n')


def srv() -> None:
  name = basename(argv[0])
  runtime_dir = environ.get(
      "XDG_RUNTIME_DIR", join(environ["HOME"], ".ssh"))
  socket_path = join(runtime_dir, "copy_socket")
  if name == "cssh":
    while True:
      supervise(argv[2:])
      sleep(1)
  if name == "csshd":
    remote_daemon(socket_path)
  elif environ.get("SSH_TTY") is not None:
    data: str = stdin.read().strip("\n")
    # if not args.tmux:
    #   tmux_cp(data)
    remote_copy(socket_path, data)
  else:
    data: str = stdin.read().strip("\n")
    # if not args.tmux:
    #   tmux_cp(data)
    clippy(data)


def main() -> None:
  try:
    srv()
  except KeyboardInterrupt:
    pass
  except Exception as e:
    print(e, file=stderr)
    print("\a")
    exit(1)


main()

